<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emotle</title>
    <script src="header.js"></script>
    <!-- Favicon: Red E emoji from URL -->
    <link rel="icon" href="favicon-32x32.png">
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="game-container">
        <!-- Game Header with Title and Icon Buttons -->
        <div class="game-header">
            <div class="icon-button" id="statsButton" title="Show Statistics">
                <!-- Different Chart Icon (e.g., bar chart) -->
                <svg viewBox="0 0 24 24">
                    <path d="M5 9.22h3V21H5zM16 3h3v18h-3zM10.5 14h3v7h-3z"/>
                </svg>
            </div>
            <h1>Emotle</h1>
            <div class="icon-button" id="howToPlayButton" title="How to Play">
                <svg viewBox="0 0 24 24">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 13.9 13 14.5 13 15h-2v-.5c0-1.1.45-2.1 1.18-2.83l1.24-1.26c.37-.36.58-.86.58-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 1.5-.78 2.8-1.93 3.5z"/>
                </svg>
            </div>
        </div>

        <p>Translate the emoji phrase:</p>
        
        <!-- Countdown Timer -->
        <div id="countdown-timer" class="hidden"></div>

        <!-- Share button for the main page -->
        <button id="mainShareButton" class="share-button hidden">Share Results</button>
        <span id="mainClipboardMessage" class="clipboard-message">Copied to clipboard!</span>

        <!-- Display area for the daily emoji phrase -->
        <div class="emoji-phrase" id="emoji-display"></div>
        
        <!-- This input field is hidden and readonly, used for capturing physical keyboard input -->
        <input type="text" id="guess-input" maxlength="50" autocomplete="off" readonly>
        
        <!-- Grid container for all guess rows (past and current) -->
        <div class="guesses-grid" id="guesses-grid">
            <!-- Guess rows will be dynamically added here -->
        </div>

        <!-- Message area for feedback (only for input errors now, no more guess count) -->
        <div id="message" class="hidden"></div>
        
        <!-- On-screen keyboard -->
        <div class="keyboard" id="on-screen-keyboard">
            <div class="keyboard-row">
                <div class="key" data-key="q">Q</div>
                <div class="key" data-key="w">W</div>
                <div class="key" data-key="e">E</div>
                <div class="key" data-key="r">R</div>
                <div class="key" data-key="t">T</div>
                <div class="key" data-key="y">Y</div>
                <div class="key" data-key="u">U</div>
                <div class="key" data-key="i">I</div>
                <div class="key" data-key="o">O</div>
                <div class="key" data-key="p">P</div>
            </div>
            <div class="keyboard-row">
                <!-- Empty div for spacing to center the row -->
                <div class="key empty" style="flex-basis: 0.5; visibility: hidden;"></div>
                <div class="key" data-key="a">A</div>
                <div class="key" data-key="s">S</div>
                <div class="key" data-key="d">D</div>
                <div class="key" data-key="f">F</div>
                <div class="key" data-key="g">G</div>
                <div class="key" data-key="h">H</div>
                <div class="key" data-key="j">J</div>
                <div class="key" data-key="k">K</div>
                <div class="key" data-key="l">L</div>
                <div class="key empty" style="flex-basis: 0.5; visibility: hidden;"></div>
            </div>
            <div class="keyboard-row">
                <div class="key large" data-key="enter">Submit</div>
                <div class="key" data-key="z">Z</div>
                <div class="key" data-key="x">X</div>
                <div class="key" data-key="c">C</div>
                <div class="key" data-key="v">V</div>
                <div class="key" data-key="b">B</div>
                <div class="key" data-key="n">N</div>
                <div class="key" data-key="m">M</div>
                <div class="key large" data-key="backspace">âŒ«</div>
            </div>
        </div>
    </div>

    <!-- Game Over/Stats Modal -->
    <div id="gameOverModal" class="modal-overlay hidden">
        <div class="modal-content">
            <button class="modal-close-button" id="statsModalCloseButton">&times;</button>
            <h2 class="modal-title" id="modalTitle"></h2>
            <div class="modal-stats">
                <p>Games Played: <strong id="gamesPlayedStat"></strong></p>
                <p>Win Rate: <strong id="winRateStat"></strong>%</p>
                <p>Avg. Guesses per Win: <strong id="avgGuessesStat"></strong></p>
            </div>
            <p id="nextPuzzleInfo" style="margin-top: 20px; font-size: 1.1em;"></p>
            <button id="shareButton" class="share-button">Share Results</button>
            <span id="clipboardMessage" class="clipboard-message">Copied to clipboard!</span>
        </div>
    </div>

    <!-- How to Play Modal -->
    <div id="howToPlayModal" class="modal-overlay hidden">
        <div class="modal-content">
            <button class="modal-close-button" id="howToPlayModalCloseButton">&times;</button>
            <h2 class="modal-title">How to Play Emotle</h2>
            <div class="modal-instructions">
                <p>Guess the hidden word that matches the emoji phrase in 5 tries.</p>
                <p>Each guess must be a valid word of the correct length. Hit the <strong>Submit button</strong> on the keyboard to submit.</p>

                <p>After each guess, the color of the tiles will change to show how close your guess was:</p>

                <h3>Examples:</h3>
                <p>The letter <strong>G</strong> is in the phrase and in the correct spot.</p>
                <div class="example-row">
                    <div class="example-box correct">G</div>
                    <div class="example-box">A</div>
                    <div class="example-box">M</div>
                    <div class="example-box">E</div>
                </div>

                <p>The letter <strong>O</strong> is in the phrase but in the wrong spot.</p>
                <div class="example-row">
                    <div class="example-box">H</div>
                    <div class="example-box present">O</div>
                    <div class="example-box">U</div>
                    <div class="example-box">S</div>
                    <div class="example-box">E</div>
                </div>

                <p>The letter <strong>X</strong> is not in the phrase in any spot.</p>
                <div class="example-row">
                    <div class="example-box absent">B</div>
                    <div class="example-box absent">O</div>
                    <div class="example-box absent">X</div>
                    <div class="example-box absent">E</div>
                    <div class="example-box absent">R</div>
                </div>
                <p>A new Emotle puzzle is available every day!</p>
            </div>
        </div>
    </div>


    <script src="game-data.js"></script>
    <script>
        const NUM_GUESSES = 5;

        // URL Parameters for Mode Handling
        const urlParams = new URLSearchParams(window.location.search);
        const isPracticeMode = urlParams.get('mode') === 'practice';

        // Game state variables
        let currentEmojiPhrase = {};
        let correctAnswerLength = 0;
        let guessesRemaining = NUM_GUESSES;
        let gameEnded = false;
        let currentGuessString = ""; // To track the current typed input
        let keyboardState = {}; // To store the color state of each keyboard key
        let guessesTakenInCurrentGame = 0; // Track guesses for current game
        let countdownInterval; // Global variable for countdown interval
        let pastGuessesData = []; // Array to store submitted guesses and their states
        let currentPuzzleIndex = 0; // Track current index for sequential practice

        // Get references to DOM elements
        const emojiDisplay = document.getElementById('emoji-display');
        const guessInput = document.getElementById('guess-input');
        const guessesGrid = document.getElementById('guesses-grid');
        const messageDisplay = document.getElementById('message');
        const keyboard = document.getElementById('on-screen-keyboard');
        const countdownTimerDisplay = document.getElementById('countdown-timer');

        // Modal elements
        const gameOverModal = document.getElementById('gameOverModal');
        const modalTitle = document.getElementById('modalTitle');
        const gamesPlayedStat = document.getElementById('gamesPlayedStat');
        const winRateStat = document.getElementById('winRateStat');
        const avgGuessesStat = document.getElementById('avgGuessesStat');
        const nextPuzzleInfo = document.getElementById('nextPuzzleInfo');
        const statsModalCloseButton = document.getElementById('statsModalCloseButton');
        const shareButton = document.getElementById('shareButton');
        const clipboardMessage = document.getElementById('clipboardMessage');

        const howToPlayModal = document.getElementById('howToPlayModal');
        const howToPlayModalCloseButton = document.getElementById('howToPlayModalCloseButton');

        // Header buttons
        const statsButton = document.getElementById('statsButton');
        const howToPlayButton = document.getElementById('howToPlayButton');

        // New elements for main page share button
        const mainShareButton = document.getElementById('mainShareButton');
        const mainClipboardMessage = document.getElementById('mainClipboardMessage');


        /**
         * Loads game statistics from local storage or initializes them if not found.
         * @returns {Object} An object containing gamesPlayed, gamesWon, and totalGuesses.
         */
        function loadStats() {
            const stats = localStorage.getItem('emotleStats');
            if (stats) {
                return JSON.parse(stats);
            }
            return {
                gamesPlayed: 0,
                gamesWon: 0,
                totalGuesses: 0
            };
        }

        /**
         * Saves game statistics to local storage.
         * @param {Object} stats - The statistics object to save.
         */
        function saveStats(stats) {
            localStorage.setItem('emotleStats', JSON.stringify(stats));
        }

        /**
         * Updates game statistics after a game ends.
         * @param {boolean} wonGame - True if the game was won, false otherwise.
         * @param {number} guessesTaken - The number of guesses taken in the current game.
         */
        function updateStats(wonGame, guessesTaken) {
            if (isPracticeMode) return loadStats(); // Don't track practice stats
            const stats = loadStats();
            stats.gamesPlayed++;
            if (wonGame) {
                stats.gamesWon++;
                stats.totalGuesses += guessesTaken; // Only add guesses if won
            }
            saveStats(stats);
            return stats;
        }

        /**
         * Calculates and returns the daily emoji phrase based on the current date.
         * The selection cycles through the `emojiPhrases` array.
         * @returns {Object} The emoji phrase object for the current day.
         */
        function getDailyEmojiPhrase() {
            if (isPracticeMode) {
                // If a specific index is provided, use it, otherwise pick at random
                const seed = urlParams.get('seed');
                currentPuzzleIndex = seed ? parseInt(seed) : Math.floor(Math.random() * emojiPhrases.length);
                return emojiPhrases[currentPuzzleIndex];
            }
            const today = new Date();
            today.setUTCHours(0, 0, 0, 0);
            
            const diffTime = Math.abs(today.getTime() - EPOCH_START_DATE.getTime());
            const diffDays = Math.floor(diffTime / MS_PER_DAY); 
            
            const index = diffDays % emojiPhrases.length;
            return emojiPhrases[index];
        }

        /**
         * Returns the current game number based on the epoch start date.
         * @returns {number} The current game number.
         */
        function getGameNumber() {
            const today = new Date();
            today.setUTCHours(0, 0, 0, 0);
            const diffTime = Math.abs(today.getTime() - EPOCH_START_DATE.getTime());
            const diffDays = Math.floor(diffTime / MS_PER_DAY);
            return diffDays + 1; // +1 to make it 1-indexed
        }

        /**
         * Generates the shareable text for the game results.
         * @param {boolean} wonGame - True if the game was won, false otherwise.
         * @param {number} guessesTaken - The number of guesses taken.
         * @param {Array<Object>} pastGuesses - Array of past guesses with their letter states.
         * @returns {string} The formatted string to be shared.
         */
        function generateShareResults(wonGame, guessesTaken, pastGuesses) {
            const gameNumber = getGameNumber();
            const guessCount = wonGame ? guessesTaken : 'X';
            let shareText = `Emotle #${gameNumber} ${guessCount}/${NUM_GUESSES}\n\n`;

            pastGuesses.forEach(guessEntry => {
                const rowEmojis = guessEntry.letterStates.map(state => {
                    if (state === 'correct') {
                        return 'ðŸŸ¦'; // Blue square for correct
                    } else if (state === 'present') {
                        return 'ðŸŸ¥'; // Red square for present (matching pink color in game)
                    } else {
                        return 'â¬›'; // Black square for absent (matching grey color in game)
                    }
                }).join('');
                shareText += rowEmojis + '\n';
            });
            shareText += "\nPlay Emotle.com"; // Changed to .com
            return shareText;
        }


        /**
         * Saves the current game state to local storage.
         * Includes the emoji phrase, guesses made, remaining attempts, and keyboard state.
         */
        function saveGameState() {
            if (isPracticeMode) return; // Don't save practice game states to persistence
            const gameState = {
                emoji: currentEmojiPhrase.emoji,
                answer: currentEmojiPhrase.answer, // Save answer too, for comparison on load
                guessesRemaining: guessesRemaining,
                guessesTakenInCurrentGame: guessesTakenInCurrentGame,
                keyboardState: keyboardState,
                pastGuessesData: pastGuessesData // Store the actual guess words and their states
            };
            localStorage.setItem('emotleGameState', JSON.stringify(gameState));
        }

        /**
         * Loads the game state from local storage.
         * Returns true if a valid state for the current daily puzzle was loaded, false otherwise.
         */
        function loadGameState() {
            if (isPracticeMode) return false; // Never load saved state for practice mode
            const savedStateStr = localStorage.getItem('emotleGameState');
            if (savedStateStr) {
                const savedState = JSON.parse(savedStateStr);

                // Check if the saved game state matches the current daily puzzle
                if (savedState.emoji === getDailyEmojiPhrase().emoji && savedState.answer === getDailyEmojiPhrase().answer) {
                    currentEmojiPhrase = { emoji: savedState.emoji, answer: savedState.answer };
                    correctAnswerLength = currentEmojiPhrase.answer.length;
                    guessesRemaining = savedState.guessesRemaining;
                    guessesTakenInCurrentGame = savedState.guessesTakenInCurrentGame;
                    keyboardState = savedState.keyboardState;
                    pastGuessesData = savedState.pastGuessesData;

                    // Re-render the past guesses
                    renderPastGuesses();
                    updateKeyboardDisplay(); // Apply keyboard states from loaded data

                    // If the loaded game was already won or lost, set gameEnded
                    if (guessesRemaining <= 0 || pastGuessesData.some(g => g.word === currentEmojiPhrase.answer)) {
                        gameEnded = true;
                        keyboard.style.pointerEvents = 'none';
                        keyboard.style.opacity = '0.5';
                        emojiDisplay.style.opacity = '0.5';
                        guessesGrid.style.opacity = '0.5';
                        showMessage('You\'ve played today\'s Emotle. Next puzzle unlocks soon!', 'info');
                        startCountdown();
                        mainShareButton.classList.remove('hidden'); // Show main share button
                        mainShareButton.style.display = 'block';
                    } else {
                        // Game in progress, ensure it's interactable
                        gameEnded = false;
                        keyboard.style.pointerEvents = 'auto';
                        keyboard.style.opacity = '1';
                        emojiDisplay.style.opacity = '1';
                        guessesGrid.style.opacity = '1';
                        stopCountdown();
                        mainShareButton.classList.add('hidden'); // Hide main share button
                    }
                    return true;
                }
            }
            return false; // No valid saved state for today's puzzle
        }

        /**
         * Renders all past guesses stored in `pastGuessesData` onto the grid.
         */
        function renderPastGuesses() {
            guessesGrid.innerHTML = ''; // Clear existing grid
            for (let i = 0; i < pastGuessesData.length; i++) { // Only iterate up to pastGuessesData length
                const guessRow = document.createElement('div');
                guessRow.classList.add('guess-row');
                guessRow.id = `guess-row-${i}`;

                const guessEntry = pastGuessesData[i];

                for (let j = 0; j < correctAnswerLength; j++) {
                    const letterBox = document.createElement('div');
                    letterBox.classList.add('letter-box');
                    if (guessEntry) {
                        letterBox.textContent = guessEntry.word[j].toUpperCase();
                        letterBox.classList.add(guessEntry.letterStates[j]);
                    }
                    guessRow.appendChild(letterBox);
                }
                guessesGrid.appendChild(guessRow);
            }
        }


        /**
         * Initializes or resets the game state and UI.
         */
        function initializeGame() {
            // First, get the daily emoji phrase
            currentEmojiPhrase = getDailyEmojiPhrase();
            currentEmojiPhrase.answer = currentEmojiPhrase.answer.replace(/\s/g, ''); 
            correctAnswerLength = currentEmojiPhrase.answer.length;

            emojiDisplay.textContent = currentEmojiPhrase.emoji;
            messageDisplay.classList.add('hidden');
            messageDisplay.textContent = '';
            
            // Try to load saved game state for today
            const loaded = loadGameState();

            if (!loaded) {
                // If no saved state for today, start a new game
                guessesRemaining = NUM_GUESSES;
                gameEnded = false;
                currentGuessString = "";
                guessesTakenInCurrentGame = 0;
                pastGuessesData = []; // Clear previous data
                guessesGrid.innerHTML = ''; // Clear previous guess rows

                // Reset keyboard state to default for a new game
                const keys = keyboard.querySelectorAll('.key');
                keys.forEach(key => {
                    key.classList.remove('correct', 'present', 'absent');
                    if (key.dataset.key && key.dataset.key.length === 1 && key.dataset.key.match(/[a-z]/i)) {
                        keyboardState[key.dataset.key.toUpperCase()] = 'default';
                    }
                });
                // Ensure keyboard display is updated for the new game
                updateKeyboardDisplay();
                stopCountdown(); // Stop countdown if starting a new game
                mainShareButton.classList.add('hidden'); // Ensure main share button is hidden
            }
            
            // Create initial empty guess rows (or fill if loaded).
            // This loop now correctly handles adding only the *remaining* empty rows
            // or no rows if all guesses are filled from a loaded state.
            const rowsToCreate = NUM_GUESSES - pastGuessesData.length;
            for (let i = 0; i < rowsToCreate; i++) {
                const guessRow = document.createElement('div');
                guessRow.classList.add('guess-row');
                guessRow.id = `guess-row-${pastGuessesData.length + i}`; // Ensure unique IDs
                
                for (let j = 0; j < correctAnswerLength; j++) {
                    const letterBox = document.createElement('div');
                    letterBox.classList.add('letter-box');
                    guessRow.appendChild(letterBox);
                }
                guessesGrid.appendChild(guessRow);
            }


            // Ensure the game state (pointers, opacities) matches whether it's ended or not
            if (gameEnded) {
                keyboard.style.pointerEvents = 'none';
                keyboard.style.opacity = '0.5';
                emojiDisplay.style.opacity = '0.5';
                guessesGrid.style.opacity = '0.5';
                mainShareButton.classList.remove('hidden'); // Show main share button if game is ended
                mainShareButton.style.display = 'block';
            } else {
                keyboard.style.pointerEvents = 'auto';
                keyboard.style.opacity = '1';
                emojiDisplay.style.opacity = '1';
                guessesGrid.style.opacity = '1';
                mainShareButton.classList.add('hidden'); // Hide main share button if game is ongoing
            }

            guessInput.focus(); 
            hideStatsModal();
            hideHowToPlayModal();
        }


        /**
         * Updates the visual display of the current guess as the user types.
         * @param {string} inputString - The current string to display in the current guess row.
         */
        function updateCurrentGuessDisplay(inputString) {
            // Calculate the correct row index based on guesses already made
            const currentRowIndex = NUM_GUESSES - guessesRemaining;
            const currentRow = document.getElementById(`guess-row-${currentRowIndex}`);
            
            if (!currentRow) return;

            const letterBoxes = currentRow.querySelectorAll('.letter-box');
            for (let i = 0; i < inputString.length; i++) {
                letterBoxes[i].textContent = inputString[i].toUpperCase();
                letterBoxes[i].style.borderColor = '#999'; // Indicate active input
            }
            for (let i = inputString.length; i < correctAnswerLength; i++) {
                letterBoxes[i].textContent = '';
                letterBoxes[i].style.borderColor = '#5a5a5a'; // Reset to default
            }
        }

        /**
         * Checks the user's guess against the correct answer and updates the UI.
         */
        function checkGuess() {
            if (gameEnded) return;

            const userGuess = currentGuessString.toUpperCase();
            const correctAnswer = currentEmojiPhrase.answer;

            if (userGuess.length !== correctAnswerLength) {
                showMessage(`Guess must be ${correctAnswerLength} letters long!`, "incorrect");
                return;
            }

            guessesTakenInCurrentGame++; // Increment guess count for the current game

            const currentRowIndex = NUM_GUESSES - guessesRemaining;
            const currentRow = document.getElementById(`guess-row-${currentRowIndex}`);
            if (!currentRow) {
                console.error("Current guess row not found!");
                return;
            }
            const letterBoxes = currentRow.querySelectorAll('.letter-box');

            const solutionLetters = correctAnswer.split('');
            const guessLetters = userGuess.split('');
            const letterStates = Array(correctAnswerLength).fill(''); 

            const tempSolution = [...solutionLetters];

            // First pass: Mark correct positions (sky blue)
            for (let i = 0; i < correctAnswerLength; i++) {
                if (guessLetters[i] === tempSolution[i]) {
                    letterStates[i] = 'correct';
                    tempSolution[i] = null; 
                }
            }

            // Second pass: Mark present letters (more saturated pink) and absent (grey)
            for (let i = 0; i < correctAnswerLength; i++) {
                if (letterStates[i] === '') { 
                    const char = guessLetters[i];
                    const indexInSolution = tempSolution.indexOf(char);
                    if (indexInSolution !== -1) {
                        letterStates[i] = 'present';
                        tempSolution[indexInSolution] = null; 
                    } else {
                        letterStates[i] = 'absent';
                    }
                }
            }

            // Store the guess data before applying to UI and updating remaining guesses
            pastGuessesData.push({ word: userGuess, letterStates: [...letterStates] });

            // Apply classes to letter boxes and update keyboard state
            for (let i = 0; i < correctAnswerLength; i++) {
                const char = guessLetters[i];
                const state = letterStates[i];
                letterBoxes[i].classList.add(state);

                const currentKeyColor = keyboardState[char] || 'default';
                if (state === 'correct') {
                    keyboardState[char] = 'correct';
                } else if (state === 'present' && currentKeyColor !== 'correct') {
                    keyboardState[char] = 'present';
                } else if (state === 'absent' && currentKeyColor === 'default') {
                    keyboardState[char] = 'absent';
                }
            }

            updateKeyboardDisplay(); // Apply updated keyboard states

            guessesRemaining--;
            saveGameState(); // Save state after each valid guess

            if (userGuess === correctAnswer) {
                localStorage.setItem('emotleLastPlayedDate', new Date().toISOString().split('T')[0]);
                endGame(true, guessesTakenInCurrentGame);
            } else {
                if (guessesRemaining <= 0) {
                    localStorage.setItem('emotleLastPlayedDate', new Date().toISOString().split('T')[0]);
                    endGame(false, guessesTakenInCurrentGame);
                }
            }
            currentGuessString = ""; 
            updateCurrentGuessDisplay(currentGuessString);
            guessInput.focus(); 
        }

        /**
         * Updates the visual appearance of the on-screen keyboard keys based on `keyboardState`.
         */
        function updateKeyboardDisplay() {
            const keys = keyboard.querySelectorAll('.key');
            keys.forEach(keyElement => {
                const char = keyElement.dataset.key ? keyElement.dataset.key.toUpperCase() : '';
                const state = keyboardState[char];
                
                keyElement.classList.remove('correct', 'present', 'absent');
                if (state && state !== 'default') {
                    keyElement.classList.add(state);
                }
            });
        }

        /**
         * Displays a message to the user with a specific type.
         * @param {string} msg - The message text to display.
         * @param {string} type - The class name to apply for styling (e.g., "win-message", "lose-message", "incorrect").
         */
        function showMessage(msg, type) {
            messageDisplay.textContent = msg;
            messageDisplay.className = 'message';
            messageDisplay.classList.add(type);
            messageDisplay.classList.remove('hidden');
            
            if (type === 'incorrect' || type === 'info') {
                setTimeout(() => {
                    messageDisplay.classList.add('hidden');
                }, 2000);
            }
        }

        /**
         * Ends the game, disabling input and showing the stats modal.
         * @param {boolean} won - True if the game was won, false otherwise.
         * @param {number} guessesTaken - Number of guesses taken in this game.
         */
        function endGame(won, guessesTaken) {
            gameEnded = true;
            keyboard.style.pointerEvents = 'none';
            keyboard.style.opacity = '0.5';
            emojiDisplay.style.opacity = '0.5';
            guessesGrid.style.opacity = '0.5';
            
            const stats = updateStats(won, guessesTaken); // This line calls updateStats
            showStatsModal(won, stats); // Pass 'won' status to modal

            mainShareButton.classList.remove('hidden'); // Show main share button
            mainShareButton.style.display = 'block';
        }

        /**
         * Displays the game over modal with updated statistics.
         * Can be called independently to show stats.
         * @param {boolean} [won] - Optional. True if the game was won, false otherwise. Determines modal title/color.
         * @param {Object} [stats] - Optional. The current game statistics. If not provided, loads from local storage.
         */
        function showStatsModal(won, stats) {
            hideHowToPlayModal();
            if (!stats) {
                stats = loadStats();
            }

            // Determine if the game was won for modal title and share button logic
            let wasGameWon;
            if (typeof won === 'boolean') { // Game just ended (win or loss)
                wasGameWon = won;
                modalTitle.textContent = won ? 'ðŸŽ‰ You Won! ðŸŽ‰' : `Game Over! The answer was "${currentEmojiPhrase.answer}".`;
                modalTitle.classList.remove('win-message', 'lose-message');
                modalTitle.classList.add(won ? 'win-message' : 'lose-message');
                startCountdown(); // Start countdown only if game officially ended
            } else if (gameEnded) { // Game was already ended (e.g., page reload after win/loss)
                wasGameWon = pastGuessesData.some(g => g.word === currentEmojiPhrase.answer);
                modalTitle.textContent = wasGameWon ? 'ðŸŽ‰ You Won! ðŸŽ‰' : `Game Over! The answer was "${currentEmojiPhrase.answer}".`;
                modalTitle.classList.remove('win-message', 'lose-message');
                modalTitle.classList.add(wasGameWon ? 'win-message' : 'lose-message');
                startCountdown(); // Resume countdown if it was an ended game
            }
            else { // Game is ongoing, user just clicked stats button
                modalTitle.textContent = 'Your Game Statistics';
                modalTitle.classList.remove('win-message', 'lose-message');
                wasGameWon = null; // Game is ongoing, not won or lost yet
                stopCountdown(); // Ensure countdown is not running if game is ongoing
            }

            gamesPlayedStat.textContent = stats.gamesPlayed;
            winRateStat.textContent = stats.gamesPlayed > 0 ? ((stats.gamesWon / stats.gamesPlayed) * 100).toFixed(1) : '0.0';
            avgGuessesStat.textContent = stats.gamesWon > 0 ? (stats.totalGuesses / stats.gamesWon).toFixed(1) : '0.0';

            if (isPracticeMode) {
                const nextPuzzleIndex = (currentPuzzleIndex + 1) % emojiPhrases.length;
                nextPuzzleInfo.innerHTML = `<button class="share-button" onclick="window.location.href='index.html?mode=practice&seed=${nextPuzzleIndex}'">Play Next Puzzle</button>`;
            } else {
                nextPuzzleInfo.textContent = 'Come back tomorrow for a new puzzle!';
            }
            
            // Only show share button if game has ended
            if (gameEnded) {
                shareButton.style.display = 'block';
            } else {
                shareButton.style.display = 'none';
            }
            clipboardMessage.classList.remove('show'); // Hide message when modal opens

            gameOverModal.classList.remove('hidden');
        }

        /**
         * Hides the game over/stats modal.
         */
        function hideStatsModal() {
            gameOverModal.classList.add('hidden');
        }

        /**
         * Displays the "How to Play" modal.
         */
        function showHowToPlayModal() {
            hideStatsModal();
            howToPlayModal.classList.remove('hidden');
        }

        /**
         * Hides the "How to Play" modal.
         */
        function hideHowToPlayModal() {
            howToPlayModal.classList.add('hidden');
        }

        /**
         * Starts the countdown timer to the next day's puzzle.
         */
        function startCountdown() {
            if (isPracticeMode) return; // No countdown in practice mode
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }

            countdownTimerDisplay.classList.remove('hidden');

            function updateCountdown() {
                const now = new Date();
                const nextMidnight = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() + 1, 0, 0, 0, 0));
                let timeRemaining = nextMidnight.getTime() - now.getTime();

                if (timeRemaining <= 0) {
                    stopCountdown();
                    localStorage.removeItem('emotleLastPlayedDate'); // Clear played date
                    localStorage.removeItem('emotleGameState'); // Clear game state for a new day
                    initializeGame(); // Re-initialize for the new day's puzzle
                    return;
                }

                const hours = Math.floor(timeRemaining / (1000 * 60 * 60));
                timeRemaining %= (1000 * 60 * 60);
                const minutes = Math.floor(timeRemaining / (1000 * 60));
                timeRemaining %= (1000 * 60);
                const seconds = Math.floor(timeRemaining / 1000);

                countdownTimerDisplay.textContent = `Next puzzle in: ${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }

            updateCountdown();
            countdownInterval = setInterval(updateCountdown, 1000);
        }

        /**
         * Stops the countdown timer and hides its display.
         */
        function stopCountdown() {
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            countdownTimerDisplay.classList.add('hidden');
        }

        /**
         * Generic function to copy text to clipboard and show a message.
         * @param {string} textToCopy - The text to copy to the clipboard.
         * @param {HTMLElement} messageElement - The element to display the "Copied" message.
         */
        function copyToClipboardAndShowMessage(textToCopy, messageElement) {
            const textarea = document.createElement('textarea');
            textarea.value = textToCopy;
            textarea.style.position = 'fixed'; // Avoid scrolling to bottom
            textarea.style.opacity = '0'; // Hide textarea
            document.body.appendChild(textarea);
            textarea.focus();
            textarea.select();

            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    messageElement.textContent = 'Copied to clipboard!';
                    messageElement.classList.add('show'); // Triggers fade-in
                    setTimeout(() => {
                        messageElement.classList.remove('show'); // Triggers fade-out
                    }, 2000); // Message is fully visible for 2 seconds, then starts fading out
                } else {
                    messageElement.textContent = 'Copy failed. Please copy manually.';
                    messageElement.classList.add('show');
                    setTimeout(() => {
                        messageElement.classList.remove('show');
                    }, 3000); // Longer display for error message
                }
            } catch (err) {
                messageElement.textContent = 'Copy failed: ' + err;
                messageElement.classList.add('show');
                setTimeout(() => {
                    messageElement.classList.remove('show');
                }, 3000);
            } finally {
                document.body.removeChild(textarea);
            }
        }


        // --- Event Listeners ---

        // Event listener for physical keyboard input on the hidden guess field
        guessInput.addEventListener('keydown', (e) => {
            if (gameEnded) {
                e.preventDefault();
                return;
            }

            const key = e.key.toUpperCase();

            if (e.key === 'Backspace') {
                e.preventDefault();
                currentGuessString = currentGuessString.slice(0, -1);
                updateCurrentGuessDisplay(currentGuessString);
                return;
            }

            if (e.key === 'Enter') {
                e.preventDefault();
                checkGuess();
                return;
            }

            if (key.length === 1 && key.match(/[A-Z]/) && currentGuessString.length < correctAnswerLength) {
                currentGuessString += key;
                updateCurrentGuessDisplay(currentGuessString);
            }
        });

        // Event listener for clicks on the on-screen keyboard
        keyboard.addEventListener('click', (e) => {
            if (gameEnded) return;

            if (!e.target.classList.contains('key') || e.target.classList.contains('empty')) {
                return;
            }

            const key = e.target.dataset.key;

            if (key === 'enter') {
                checkGuess();
            } else if (key === 'backspace') {
                currentGuessString = currentGuessString.slice(0, -1);
            } else if (key.length === 1 && key.match(/[a-z]/) && currentGuessString.length < correctAnswerLength) {
                currentGuessString += key.toUpperCase();
            }
            
            updateCurrentGuessDisplay(currentGuessString);
            guessInput.focus();
        });

        // Event listener to focus the hidden input when clicking anywhere on the body
        document.body.addEventListener('click', (e) => {
            if (!gameEnded && !e.target.closest('.modal-overlay')) {
                guessInput.focus();
            }
        });

        // Event listeners for the modal buttons
        statsModalCloseButton.addEventListener('click', hideStatsModal);
        howToPlayModalCloseButton.addEventListener('click', hideHowToPlayModal);

        // Event listeners for the new header icon buttons
        statsButton.addEventListener('click', () => showStatsModal(undefined, loadStats())); 
        howToPlayButton.addEventListener('click', showHowToPlayModal);

        // Event listener for Share button in the modal
        shareButton.addEventListener('click', () => {
            const wasWon = pastGuessesData.some(g => g.word === currentEmojiPhrase.answer);
            const shareText = generateShareResults(wasWon, guessesTakenInCurrentGame, pastGuessesData);
            copyToClipboardAndShowMessage(shareText, clipboardMessage);
        });

        // Event listener for Share button on the main page
        mainShareButton.addEventListener('click', () => {
            const wasWon = pastGuessesData.some(g => g.word === currentEmojiPhrase.answer);
            const shareText = generateShareResults(wasWon, guessesTakenInCurrentGame, pastGuessesData);
            copyToClipboardAndShowMessage(shareText, mainClipboardMessage);
        });


        // Initialize the game when the entire HTML document has been loaded and parsed
        document.addEventListener('DOMContentLoaded', initializeGame);
    </script>
    <script src="footer.js"></script>
    <footer class="site-footer"></footer>
</body>
</html>